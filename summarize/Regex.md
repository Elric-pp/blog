## 正则表达式学习笔记

[来源](http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html)

## 目录
    1. 元字符
    1. 字符转义
    1. 重复
    1. 字符类
    1. 分支条件
    1. 反义   
    1. 分组
    1. 后向引用
    1. 零宽断言
    1. 注释
    1. 贪婪与懒惰
    1. 处理选项
    1. 平衡组/递归匹配
    1. 补充

### 元字符
常用元字符
 *元字符* | *说明*
 .               | 匹配除换行符以外的任意字符
 \w            | 匹配字母或数字或下划线或汉字
 \s             | 匹配任意得空白符
 \d            | 匹配数字
 \b            | 匹配单词的开始或结束
 ^              | 匹配字符串的开始
 $              | 匹配字符串的结束

### 重复
常用的限定符
*语法*  | *说明* 
`*`       | 重复零次或更多次 
`+`       | 重复一次或更多次 
`?`        | 重复零次或者一次 
`{n}`     | 重复n次 
`{n, }`   | 重复n次或更多次 
`{n, m}`| 重复n到m次 

### 字符类
使用一组方括号来制定字符范围, 如 `[aeiou]` 匹配任何一个英文元音字母

### 分支条件
分支条件指几种规则,如果满足其中任意一种规则都应该当成匹配, 具体方法是用`|` 把不同规则分开

### 分组
将多个字符用`() `包起来, 用来指定子表达式(也叫做分组), 你可以对子表达式做一些操作
常用分组语法
 *分类*    | *语法*                | *说明*
 -------------|------------------------| -----------
 捕获        | `(exp)`                | 匹配exp, 并捕获文本到自动命名的组里 
                | `(?<name>exp)` | 匹配exp,并捕获文本到名称为name的组里, 也可以写成(?'name'exp)
                | `(?:exp)`             | 匹配exp,不捕获匹配的文本, 也不给此分组分配组号
 零宽断言 | `(?=exp)`            | 匹配exp前面的位置
                | `(?<=exp)`          | 匹配exp后面的位置
                | `(?!exp)`             | 匹配后面跟的不是exp的位置
                | `(?<!exp)`           | 匹配前面不是exp的位置
 注释        | (?#comment)      | 这种类型的分组不对正则表达式的处理产生任何影响,只提供注释供阅读 


### 反义
常用的反义代码
*语法* | *说明* 
`\W` | 匹配不是字母, 数字, 下划线, 汉字的字符 
`\S` | 匹配任意不是空白符的字符 
`\D` | 匹配任意非数字的字符 
`\B` | 匹配不是单词开头或结束的位置 
`[^x]|| 匹配除x之外的任意字符 
`[^aeiou]` | 匹配除aeiou之外的任意字符 


### 后向引用
根据分组组号对分组进行引用


### 零宽断言 
`(?=exp)` 断言自身的出现的位置的后面能匹配表达式exp
> `\b\w+(?=ing\b)` 匹配以ing结尾的单词的前面部分(不包括ing), `reading` --> `read`

`(?<=exp)` 断言自身出现的位置的前面能匹配表达式exp
> `(?<=\bre)\w+\b` 匹配以re开头的单词的后半部分(不包括re), `reading` --> `ading`

### 负向零宽断言
`(?!exp)` 断言此位置的前面不能匹配表达式exp, `\d{3}(?!\d)` 匹配三位数字, 后面不能是数字

`(?<!exp)` 断言此位置的前面不能匹配表达式exp, `(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字

### 贪婪和懒惰
> 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

> 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

> a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

懒惰限定符
 *语法*  | *说明*
 -----------|----------- 
 `*?`      | 重复任意次, 但尽可能少重复
 `+?`      | 重复一次或者更多次, 但尽可能少重复
 `??`       | 重复0次或1次, 但尽可能少重复
 `{n}`     | 重复n次以上, 但尽可能少重复
 `{n,m}` | 重复n到m次, 但尽可能少重复


